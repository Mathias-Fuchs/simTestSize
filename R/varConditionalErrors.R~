#' the variance across several independent realizations of the conditional error
#'
#' computes the average error of a single training iteration
#' @param learningAlgorithm a function that takes learning data as argument and outputs a prediction rule in the form of another function that maps test data to numeric vectors. These can be errors or AUCs, one for each testing data set.
#' @param drawFunction a function that returns a dataframe with the response variable in a column names y
#' @param innerAccuracy the accuracy to which each conditional error is approximated
#' @param outerAccuracy the accuracy to which the variance is determined
#' @return the results of a variance confidence interval across the learning iterations
#' @examples
#' varConditionalErrors(
#' learningAlgorithm=svmLearning,
#' drawFunction=drawLogit,
#' innerAccuracy=.05,
#' outerAccuracy=.0015
#' )
#' @export


varConditionalErrors <- function(learningAlgorithm, drawFunction, innerAccuracy=6e-2, outerAccuracy=1e-2) {

    alpha <- .05
    widthOuter <- 1/0
    resOuter <- rep(NA, 1e6)
    currentOuter <- 1
    while(widthOuter > outerAccuracy) {
        widthInner <- 1/0
        resInner <- rep(NA, 1e6)
        currentInner <- 1
        while (widthInner > innerAccuracy) {
            resInner[currentInner] <- learningAlgorithm(drawFunction())(drawFunction())
            ttest <- try(t.test(resInner, na.rm=TRUE), silent=TRUE)
            if (!(inherits(ttest, "try-error")))
                widthInner <- ttest$conf.int[2] - ttest$conf.int[1]
            currentInner <- currentInner + 1
        }        
        resOuter[currentOuter] <- mean(resInner, na.rm=TRUE)


                                        # currently achieved width of the confidence interval for the variance
        n <- sum(!is.na(resOuter))
        if (n == 1) widthOuter <- 1/0
        else 
            widthOuter <- (n-1) * var(resOuter, na.rm=TRUE) * (1/qchisq(df=n - 1, alpha/2) - 1/qchisq(df=n - 1, 1 - alpha/2))
        currentOuter <- currentOuter + 1
    }
        
    return(
        list(
            lower= (n-1) * var(resOuter, na.rm=TRUE) / qchisq(df=n - 1, 1 - alpha/2),
            point=var(resOuter, na.rm=TRUE),
            upper= (n-1) * var(resOuter, na.rm=TRUE) / qchisq(df=n - 1, alpha/2)
        )
    )
}


    
